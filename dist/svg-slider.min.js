(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["svg-slider"] = factory();
	else
		root["svg-slider"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });



/**
 *
 * @param elem DIV or SVN element
 * @param conf optional config
 * @returns {{value, config}}
 */
/* harmony default export */ __webpack_exports__["default"] = (function(elem, conf = {}) {

    if (!elem) {
        throw 'You must pass a DOM node reference to the slider constructor';
    }

    let trace = false;    // when true, will log more details in the console; use enableDebug(), disableDebug() to change

    // It is faster to access a property than to access a variable...
    // See https://jsperf.com/vars-vs-props-speed-comparison/1

    const NS = "http://www.w3.org/2000/svg";

    //---------------------------------------------------------------------
    // To simplify the internal coordinates transformations, we set the view box as a 100 by 100 square.

    const VIEWBOX_HEIGHT = 100;

    let svg_element;
    if (elem.nodeName.toLowerCase() === 'svg') {
        svg_element = elem;
    } else {
        svg_element = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        elem.appendChild(svg_element);
    }

    let defaults = {

        // User configurable properties. The colors are defined in the 'palettes', later on.

        // No camelCase because we want to be able to have the same name in data- attributes.

        label: false,

        default_value: 0,
        initial_value: 0,
        value_min: 0.0,
        value_max: 100.0,
        value_resolution: 1,        // null means ignore

        center_zero: false,
        center_value: null,         // if null, the value will be computed from the min and max in the init() method

        position_min: 0,
        position_max: 100,

        // background:
        bg_width: 20,
        bg_border_width: 1,

        // track background:
        track_bg_width: 10,

        // track:
        track_width: 10,

        // cursor
        cursor_width: 18,         
        cursor_length: 10,

        // appearance:
        bg: false,
        track_bg: true,
        track: true,
        cursor: false,
        // CSS class names
        linecap: 'butt',                   // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-linecap
        value_text: true,
        // value_position: HALF_HEIGHT + 8,    // empirical value: HALF_HEIGHT + config.font_size / 3
        // value_formatting: null,          // TODO; callback function
        format: v => v,                     // formatting of the displayed value
    
        font_family: 'sans-serif',
        font_size: 25,
        font_weight: 'bold',
        
        markers: 0,                         // number of markers; 0 or false to disable
        markers_length: 8,
        markers_width: 12,

        class_bg: 'slider-bg',
        class_track_bg : 'slider-track-bg',
        class_track : 'slider-track',
        class_value : 'slider-value',
        class_cursor : 'slider-cursor',
        class_markers: 'slider-markers',

        snap_to_steps: false,       // TODO

        // mouse wheel support:
        mouse_wheel_acceleration: 1,

        onchange: null              // callback function
    };

    //---------------------------------------------------------------------
    // Consolidate all configs:

    let data_config = JSON.parse(elem.dataset.config || '{}');
    // let c = Object.assign({}, defaults, palettes[defaults.palette], conf, data_config);
    let config = Object.assign({}, defaults, conf, data_config);
    // we re-assign conf and data_config for the case they override some of the palette colors.
    // let config = Object.assign(c, palettes[c.palette], conf, data_config);

    //---------------------------------------------------------------------
    // Terminates the SVG element setup:

    let viewbox_height = 100;
/*
    if (config.label || (config.value_position >= (100 - (config.font_size / 2)))) {
        // make some room for the label or the value that we want to display below the slider
        viewbox_height = 120;
    } else {
        viewbox_height = 100;
    }
*/

    // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML
    svg_element.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
    svg_element.setAttributeNS(null, "viewBox", `0 0 ${VIEWBOX_WIDTH} ${viewbox_height}`);

    //---------------------------------------------------------------------
    // internals

    let value = 0.0;                    // current slider's value [value_min..value_max]
    let position = config.position_min;       // current knob's position in [deg] and in knob's coordinate (not polar)
    let mouse_wheel_direction = 1;      // dependant of the OS

    //---------------------------------------------------------------------
    // SVG elements, from back to front:
    let svg_bg = null;           // background disk:
    let svg_track_bg = null;            // track background; for non zero-centered sliders
    let svg_track = null;
    let svg_cursor = null;
    let svg_divisions = null;
    let svg_value_text = null;

    //---------------------------------------------------------------------
    // mouse support
    let targetRect;
    let minDeltaY;

    //---------------------------------------------------------------------
    // true if the current slider value is different from the default value
    let has_changed = false;    // to spare some getValue() calls when testing if value has changed from default_value

    //---------------------------------------------------------------------
    // Create the slider:

    init();
    draw();
    attachEventHandlers();


    /**
     * Having a init function allow the slider to be re-configured.
     */
    function init() {

        if (config.center_zero) {
            if (!config.center_value) {
                config.center_value = getRoundedValue((config.value_max - config.value_min) / 2 + config.value_min);
            }
        }

        // set initial value and position:
        setValue(config.initial_value ? config.initial_value : config.default_value);

        // mouse_wheel_direction = _isMacOS() ? -1 : 1; //TODO: really necessary?
    }

    /**
     * Return the value "rounded" according to config.value_resolution
     * @param v value
     */
    function getRoundedValue(v) {
        return config.value_resolution === null ? v : Math.round(v / config.value_resolution) * config.value_resolution;
    }

    /**
     *
     * @param position [deg] in slider's coordinates
     * @returns {*}
     */
    function getDisplayValue(position) {
        let v = getValue(position);
        return config.format(v);
    }

    /**
     * Get the slider's value determined by the slider's position (position)
     * @param a [deg] in slider's coordinates
     * @returns {number}
     */
    function getValue(a) {
        let v = (((a || position) - config.position_min) / (config.position_max - config.position_min)) * (config.value_max - config.value_min) + config.value_min;
        return getRoundedValue(v);
    }

    /**
     * Set slider's value
     * @param v
     */
    function setValue(v) {
        if (v < config.value_min) {
            value = config.value_min;
        } else if (v > config.value_max) {
            value = config.value_max;
        } else {
            value = v;
        }
        setPosition(((v - config.value_min) / (config.value_max - config.value_min)) * (config.position_max - config.position_min) + config.position_min);
        return true;
    }

    /**
     * Set slider's position
     * @param new_position in [deg]
     */
    function setPosition(new_position, fire_event) {
        let prev = position;
        let notify = fire_event && (new_position !== position);
        position = Math.min(Math.max(new_position, config.position_min), config.position_max);
        if (notify) {
            // fire the event if the change of position affect the value:
            if (getValue(prev) !== getValue()) {
                notifyChange();
            }
        }
    }

    /**
     * Increment (or decrement if the increment is negative) the slider's position.
     * @param increment
     */
    function incPosition(increment) {
        setPosition(Math.min(Math.max(position + increment, config.position_min), config.position_max), true);
    }

    /**
     * Return polar coordinates position from our "slider coordinates" position
     */
    function sliderToPolarPosition(position) {
        let a = config.zero_at - position;
        if (a < 0) a = a + 360.0;
        if (trace) console.log(`sliderToPolarPosition ${position} -> ${a}`);
        return a;
    }

    /**
     *
     * @param position [deg] with 0 at 3 o'clock
     * @returns {number}
     */
    function polarTosliderPosition(position) {
        // "-" for changing CCW to CW
        if (trace) console.log(`polarTosliderPosition ${position} -> ${(config.zero_at - position + 360.0) % 360.0}`);
        return (config.zero_at - position + 360.0) % 360.0;    // we add 360 to handle negative values down to -360
    }

    /**
     * startDrag() must have been called before to init the targetRect variable.
     */
    function mouseUpdate(e) {

        // MouseEvent.clientX (standard property: YES)
        // The clientX read-only property of the MouseEvent interface provides
        // the horizontal coordinate within the application's client area at which
        // the event occurred (as opposed to the coordinates within the page).
        // For example, clicking in the top-left corner of the client area will always
        // result in a mouse event with a clientX value of 0, regardless of whether
        // the page is scrolled horizontally. Originally, this property was defined
        // as a long integer. The CSSOM View Module redefined it as a double float.

        let dxPixels = e.clientX - targetRect.left;
        let dyPixels = e.clientY - targetRect.top;

        // mouse delta in cartesian coordinate with path center=0,0 and scaled (-1..0..1) relative to path:
        // <svg> center:       (dx, dy) == ( 0,  0)
        // <svg> top-left:     (dx, dy) == (-1,  1)
        // <svg> bottom-right: (dx, dy) == ( 1, -1) (bottom right of the 100x100 viewBox, ignoring the bottom 100x20 for the label)
        let dx = (dxPixels - arcCenterXPixels) / (targetRect.width / 2);
        let dy = - (dyPixels - arcCenterYPixels) / (targetRect.width / 2);  // targetRect.width car on a 20px de plus en hauteur pour le label

        if (config.rotation === CCW) dx = - dx;

        // convert to polar coordinates
        let position_rad = Math.atan2(dy, dx);
        if (position_rad < 0) position_rad = 2.0*Math.PI + position_rad;

        if (trace) console.log(`mouseUpdate: position in svg = ${dxPixels}, ${dyPixels} pixels; ${dx.toFixed(3)}, ${dy.toFixed(3)} rel.; position ${position_rad.toFixed(3)} rad`);

        setPosition(polarTosliderPosition(position_rad * 180.0 / Math.PI), true);

        // distance from arc center to mouse position:
        // distance = Math.sqrt(dx*(HALF_WIDTH/config.track_width)*dx*(HALF_WIDTH/config.track_width) + dy*(HALF_HEIGHT/config.track_width)*dy*(HALF_HEIGHT/config.track_width));
    }

    /**
     *
     * @param e
     */
    function startDrag(e) {

        if (trace) console.log('startDrag');

        e.preventDefault();

        // API: Event.currentTarget
        //      Identifies the current target for the event, as the event traverses the DOM. It always REFERS TO THE ELEMENT
        //      TO WHICH THE EVENT HANDLER HAS BEEN ATTACHED, as opposed to event.target which identifies the element on
        //      which the event occurred.
        //      https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget

        // currentTarget = e.currentTarget;

        // API: Element.getBoundingClientRect() (standard: YES)
        //      The Element.getBoundingClientRect() method returns the size of an element
        //      and its POSITION RELATIVE TO THE VIEWPORT.
        //      The amount of scrolling that has been done of the viewport area (or any other
        //      scrollable element) is taken into account when computing the bounding rectposition.
        //      This means that the rectposition's boundary edges (top, left, bottom, and right)
        //      change their values every time the scrolling position changes (because their
        //      values are relative to the viewport and not absolute).
        //      https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect

        // targetRect = currentTarget.getBoundingClientRect(); // currentTarget must be the <svg...> object
        targetRect = svg_element.getBoundingClientRect();

        // Note: we must take the boundingClientRect of the <svg> and not the <path> because the <path> bounding rect
        //       is not constant because it encloses the current arc.


        document.addEventListener('mousemove', handleDrag, false);
        document.addEventListener('mouseup', endDrag, false);

        mouseUpdate(e);
        redraw();
    }

    /**
     *
     * @param e
     */
    function handleDrag(e) {
        e.preventDefault();
        mouseUpdate(e);
        redraw();
    }

    /**
     *
     */
    function endDrag() {
        if (trace) console.log('endDrag');
        document.removeEventListener('mousemove', handleDrag, false);
        document.removeEventListener('mouseup', endDrag, false);
    }

    /**
     *
     * @param e
     * @returns {boolean}
     */
    function mouseWheelHandler(e) {

        // WheelEvent
        // This is the standard wheel event interface to use. Old versions of browsers implemented the two non-standard
        // and non-cross-browser-compatible MouseWheelEvent and MouseScrollEvent interfaces. Use this interface and avoid
        // the latter two.
        // The WheelEvent interface represents events that occur due to the user moving a mouse wheel or similar input device.

        // https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers
        // https://github.com/facebook/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js

        e.preventDefault();

        let dy = e.deltaY;

        if (dy !== 0) {
            // normalize Y delta
            if (minDeltaY > Math.abs(dy) || !minDeltaY) {
                minDeltaY = Math.abs(dy);
            }
        }

        incPosition(dy / minDeltaY * mouse_wheel_direction * config.mouse_wheel_acceleration);

        // TODO: mouse speed detection (https://stackoverflow.com/questions/22593286/detect-measure-scroll-speed)

        redraw();

        return false;
    }

    /**
     *
     */
    function attachEventHandlers() {
        svg_element.addEventListener("mousedown", function(e) {
            startDrag(e);
        });
        svg_element.addEventListener("wheel", function(e) {
            mouseWheelHandler(e);
        });
    }

    /**
     *
     */
    function notifyChange() {
        if (trace) console.log('slider value has changed');
        let value = getValue();     // TODO: cache the value
        let event = new CustomEvent('change', {'detail': value});
        //svg_element.dispatchEvent(event);
        elem.dispatchEvent(event);
        if (config.onchange) {
            config.onchange(value);
        }
    }

    /**
     * Utility function to configure the mousewheel direction.
     * @returns {*}
     * @private
     */
    function _isMacOS() {
        return ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(window.navigator.platform) !== -1;
    }

    /**
     * Return viewBox X,Y coordinates
     * @param position in [degree] (polar, 0 at 3 o'clock)
     * @param radius; defaults to config.radius
     * @returns {{x: number, y: number}}
     */
    function getViewboxCoord(position, radius) {
/*
        let a = position * Math.PI / 180.0;
        let r = radius || config.track_width;
        let x = Math.cos(a) * r;
        let y = Math.sin(a) * r;
        return {
            x: config.rotation === CW ? (HALF_WIDTH + x) : (HALF_WIDTH - x),
            y: HALF_HEIGHT - y
        }
*/
    }

    /**
     *
     * @param from_position in [degree] in slider's coordinates
     * @param to_position in [degree] in slider's coordinates
     * @param radius
     */
    function getArc(from_position, to_position, radius) {

        if (trace) console.group(`getArc(${from_position}, ${to_position}, ${radius})`);

        // SVG d: "A rx,ry xAxisRotate LargeArcFlag,SweepFlag x,y".
        // SweepFlag is either 0 or 1, and determines if the arc should be swept in a clockwise (1), or anti-clockwise (0) direction
        // ref: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d

        let a0 = sliderToPolarPosition(from_position);
        let a1 = sliderToPolarPosition(to_position);

        // little trick to force a full arc (360deg) when from=0 and to=360
        if (from_position !== to_position) {
            // with this we make sure that x1 will be different than x0 within the path definition
            a0 -= 0.0001;
            a1 += 0.0001;
        }

        let {x: x0, y: y0} = getViewboxCoord(a0, radius);
        let {x: x1, y: y1} = getViewboxCoord(a1, radius);

        let delta_position = (a0 - a1 + 360.0) % 360.0;

        let large_arc = delta_position < 180.0 ? 0 : 1;
        let arc_direction = config.rotation === CW ? 1 : 0;

        let p = `M ${x0},${y0} A ${radius},${radius} 0 ${large_arc},${arc_direction} ${x1},${y1}`;

        if (trace) console.groupEnd();
        if (trace) console.log("arc: " + p);

        return p;
    }

    /**
     *
     * @returns {*}
     */
    function getTrackPath() {

        let p = null;

        if (config.center_zero) {

            if (getValue() === config.center_value) {
                if (trace) console.log('getTrackPath: center position, track not drawn');
                // track is not drawn when the value is at center
                return p;
            }

            // we assume the split is at 180 [deg] (slider's position)
            if (position < 180) {
                p = getArc(Math.min(position, left_track_end_position), left_track_end_position, config.track_width);
            } else if (position > 180) {
                p = getArc(right_track_start_position, Math.max(position, right_track_start_position), config.track_width);
            }

        } else {
            p = getArc(config.position_min, position, config.track_width);
        }

        return p;
    }

    /**
     *
     */
    function draw_background() {

        if (!config.bg) return;

        // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML

        //
        // back disk:
        //
        svg_bg = document.createElementNS(NS, "circle");
        svg_bg.setAttributeNS(null, "cx", `${HALF_WIDTH}`);
        svg_bg.setAttributeNS(null, "cy", `${HALF_HEIGHT}`);
        svg_bg.setAttributeNS(null, "r", `${config.bg_width}`);
        svg_bg.setAttribute("fill", `${config.bg_color}`);
        svg_bg.setAttribute("stroke", `${config.bg_border_color}`);
        svg_bg.setAttribute("stroke-width", `${config.bg_border_width}`);
        svg_bg.setAttribute("class", config.class_bg);
        svg_element.appendChild(svg_bg);
    }

    /**
     *
     */
    function draw_markers() {

        if (!config.markers) return;

        let p = '';
        let step = (config.position_max - config.position_min) / config.markers;
        for (let a = config.position_min; a <= config.position_max; a += step) {
            let from = getViewboxCoord(sliderToPolarPosition(a), config.markers_width);    // getViewboxCoord(position, radius)
            let to = getViewboxCoord(sliderToPolarPosition(a), config.markers_width + config.markers_length);
            p += `M ${from.x},${from.y} L ${to.x},${to.y} `;
        }

        svg_divisions = document.createElementNS(NS, "path");
        svg_divisions.setAttributeNS(null, "d", p);
        svg_divisions.setAttribute("stroke", `${config.markers_color}`);
        svg_divisions.setAttribute("stroke-width", `${config.markers_width}`);
        svg_divisions.setAttribute("stroke-linecap", config.linecap);
        svg_divisions.setAttribute("class", config.class_markers);
        svg_element.appendChild(svg_divisions);
    }

    /*
            function draw_units() {
                let pos = getViewboxCoord(position_min_polar, config.divisions_width);    // getViewboxCoord(position, radius)
                svg_value_text = document.createElementNS(NS, "text");
                svg_value_text.setAttributeNS(null, "x", `${pos.x}`);
                svg_value_text.setAttributeNS(null, "y", `${pos.y}`);
                // svg_value_text.setAttribute("text-anchor", "middle");
                svg_value_text.setAttribute("cursor", "default");
                svg_value_text.setAttribute("font-family", config.font_family);
                svg_value_text.setAttribute("font-size", `10`);
                // svg_value_text.setAttribute("font-weight", `${config.font_weight}`);
                svg_value_text.setAttribute("fill", config.font_color);
                // svg_value_text.setAttribute("class", config.class_value);
                // svg_value_text.textContent = getDisplayValue();
                svg_value_text.textContent = config.value_min.toString();
                svg_element.appendChild(svg_value_text);
            }
    */

    /**
     *
     */
    function draw_track_background() {

        // For the use of null argument with setAttributeNS, see https://developer.mozilla.org/en-US/docs/Web/SVG/Namespaces_Crash_Course#Scripting_in_namespaced_XML

        if (!config.track_bg) return;

        //
        // track background:
        //

/*
            svg_track_bg = document.createElementNS(NS, "path");
            svg_track_bg.setAttributeNS(null, "d", getArc(config.position_min, config.position_max, config.track_bg_width));
            svg_track_bg.setAttribute("stroke", `${config.track_bg_color}`);
            svg_track_bg.setAttribute("stroke-width", `${config.track_bg_width}`);
            svg_track_bg.setAttribute("fill", "transparent");
            svg_track_bg.setAttribute("stroke-linecap", config.linecap);
            svg_track_bg.setAttribute("class", config.class_track_bg);
            svg_element.appendChild(svg_track_bg);
*/

        // }
    }

    /**
     *
     */
    function draw_track() {
        if (!config.track) return;
        let p = getTrackPath();
        if (p) {
/*
            svg_track = document.createElementNS(NS, "path");
            svg_track.setAttributeNS(null, "d", p);
            svg_track.setAttribute("stroke", `${config.track_color_init}`);
            svg_track.setAttribute("stroke-width", `${config.track_width}`);
            svg_track.setAttribute("fill", "transparent");
            svg_track.setAttribute("stroke-linecap", config.linecap);
            svg_track.setAttribute("class", config.class_track);
            svg_element.appendChild(svg_track);
*/
        }
    }

    /**
     *
     * @returns {string}
     */
    function getTrackCursor() {
        // let a = sliderToPolarPosition(position);
        let from = getViewboxCoord(a, config.cursor_width);
        let to = getViewboxCoord(a, config.cursor_width + config.cursor_length);
        return `M ${from.x},${from.y} L ${to.x},${to.y}`;
    }

    /**
     *
     */
    function draw_cursor() {

        if (!config.cursor) return;

        let p = getTrackCursor();
        if (p) {
/*
            svg_cursor = document.createElementNS(NS, "path");
            svg_cursor.setAttributeNS(null, "d", p);
            svg_cursor.setAttribute("stroke", `${config.cursor_color_init}`);
            svg_cursor.setAttribute("stroke-width", `${config.cursor_width}`);
            svg_cursor.setAttribute("fill", "transparent");
            svg_cursor.setAttribute("stroke-linecap", config.linecap);
            svg_cursor.setAttribute("class", config.class_cursor);
            svg_element.appendChild(svg_cursor);
*/
        }
    }

    /**
     *
     */
    function draw_value() {

        if (!config.value_text) return;

/*
        svg_value_text = document.createElementNS(NS, "text");
        svg_value_text.setAttributeNS(null, "x", `${HALF_WIDTH}`);
        svg_value_text.setAttributeNS(null, "y", `${config.value_position}`);
        svg_value_text.setAttribute("text-anchor", "middle");
        svg_value_text.setAttribute("cursor", "default");
        svg_value_text.setAttribute("font-family", config.font_family);
        svg_value_text.setAttribute("font-size", `${config.font_size}`);
        svg_value_text.setAttribute("font-weight", `${config.font_weight}`);
        svg_value_text.setAttribute("fill", config.font_color);
        svg_value_text.setAttribute("class", config.class_value);
        svg_value_text.textContent = getDisplayValue();
        svg_element.appendChild(svg_value_text);
*/
    }

    /**
     *
     */
    function draw() {
        draw_background();
        draw_track_background();
        draw_markers();
        // draw_units();
        draw_track();
        draw_cursor();
        draw_value();
    }

    /**
     *
     */
    function redraw() {

        let p = getTrackPath();
        if (p) {
            if (svg_track) {
                svg_track.setAttributeNS(null, "d", p);
            } else {
                draw_track();
            }
        } else {
            if (svg_track) {
                svg_track.setAttributeNS(null, "d", "");    // we hide the track
            }
        }

        if (!has_changed) {
            has_changed = getValue() !== config.default_value;
            if (has_changed) {
                if (svg_track) {
                    svg_track.setAttribute("stroke", `${config.track_color}`);
                }
            }
        }

        p = getTrackCursor();
        if (p) {
            if (svg_cursor) {
                svg_cursor.setAttributeNS(null, "d", p);
                if (has_changed) {
                    svg_cursor.setAttribute("stroke", `${config.cursor_color}`);
                }
            }
        }

        if (svg_value_text) {
            svg_value_text.textContent = getDisplayValue();
        }
    }

    /**
     *
     */
    return {
        set value(v) {
            setValue(v);
            redraw();
        },
        set config(new_config) {
            config = Object.assign({}, defaults, conf, new_config);
            init();
            draw();
        },
        enableDebug: function() {
            trace = true;
        },
        disableDebug: function() {
            trace = false;
        }
    };

});


/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCBjZjRiMTI3ZjFlYTQ5ZTU0ZmYyMCIsIndlYnBhY2s6Ly8vLi9zcmMvc3ZnLXNsaWRlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDNURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsdUZBQXVDOztBQUV2QztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHVEQUF1RDs7QUFFN0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtQkFBbUI7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoic3ZnLXNsaWRlci5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJzdmctc2xpZGVyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInN2Zy1zbGlkZXJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgY2Y0YjEyN2YxZWE0OWU1NGZmMjAiLCJcblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZWxlbSBESVYgb3IgU1ZOIGVsZW1lbnRcbiAqIEBwYXJhbSBjb25mIG9wdGlvbmFsIGNvbmZpZ1xuICogQHJldHVybnMge3t2YWx1ZSwgY29uZmlnfX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZWxlbSwgY29uZiA9IHt9KSB7XG5cbiAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgdGhyb3cgJ1lvdSBtdXN0IHBhc3MgYSBET00gbm9kZSByZWZlcmVuY2UgdG8gdGhlIHNsaWRlciBjb25zdHJ1Y3Rvcic7XG4gICAgfVxuXG4gICAgbGV0IHRyYWNlID0gZmFsc2U7ICAgIC8vIHdoZW4gdHJ1ZSwgd2lsbCBsb2cgbW9yZSBkZXRhaWxzIGluIHRoZSBjb25zb2xlOyB1c2UgZW5hYmxlRGVidWcoKSwgZGlzYWJsZURlYnVnKCkgdG8gY2hhbmdlXG5cbiAgICAvLyBJdCBpcyBmYXN0ZXIgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhbiB0byBhY2Nlc3MgYSB2YXJpYWJsZS4uLlxuICAgIC8vIFNlZSBodHRwczovL2pzcGVyZi5jb20vdmFycy12cy1wcm9wcy1zcGVlZC1jb21wYXJpc29uLzFcblxuICAgIGNvbnN0IE5TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUbyBzaW1wbGlmeSB0aGUgaW50ZXJuYWwgY29vcmRpbmF0ZXMgdHJhbnNmb3JtYXRpb25zLCB3ZSBzZXQgdGhlIHZpZXcgYm94IGFzIGEgMTAwIGJ5IDEwMCBzcXVhcmUuXG5cbiAgICBjb25zdCBWSUVXQk9YX0hFSUdIVCA9IDEwMDtcblxuICAgIGxldCBzdmdfZWxlbWVudDtcbiAgICBpZiAoZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xuICAgICAgICBzdmdfZWxlbWVudCA9IGVsZW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3ZnX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChzdmdfZWxlbWVudCk7XG4gICAgfVxuXG4gICAgbGV0IGRlZmF1bHRzID0ge1xuXG4gICAgICAgIC8vIFVzZXIgY29uZmlndXJhYmxlIHByb3BlcnRpZXMuIFRoZSBjb2xvcnMgYXJlIGRlZmluZWQgaW4gdGhlICdwYWxldHRlcycsIGxhdGVyIG9uLlxuXG4gICAgICAgIC8vIE5vIGNhbWVsQ2FzZSBiZWNhdXNlIHdlIHdhbnQgdG8gYmUgYWJsZSB0byBoYXZlIHRoZSBzYW1lIG5hbWUgaW4gZGF0YS0gYXR0cmlidXRlcy5cblxuICAgICAgICBsYWJlbDogZmFsc2UsXG5cbiAgICAgICAgZGVmYXVsdF92YWx1ZTogMCxcbiAgICAgICAgaW5pdGlhbF92YWx1ZTogMCxcbiAgICAgICAgdmFsdWVfbWluOiAwLjAsXG4gICAgICAgIHZhbHVlX21heDogMTAwLjAsXG4gICAgICAgIHZhbHVlX3Jlc29sdXRpb246IDEsICAgICAgICAvLyBudWxsIG1lYW5zIGlnbm9yZVxuXG4gICAgICAgIGNlbnRlcl96ZXJvOiBmYWxzZSxcbiAgICAgICAgY2VudGVyX3ZhbHVlOiBudWxsLCAgICAgICAgIC8vIGlmIG51bGwsIHRoZSB2YWx1ZSB3aWxsIGJlIGNvbXB1dGVkIGZyb20gdGhlIG1pbiBhbmQgbWF4IGluIHRoZSBpbml0KCkgbWV0aG9kXG5cbiAgICAgICAgcG9zaXRpb25fbWluOiAwLFxuICAgICAgICBwb3NpdGlvbl9tYXg6IDEwMCxcblxuICAgICAgICAvLyBiYWNrZ3JvdW5kOlxuICAgICAgICBiZ193aWR0aDogMjAsXG4gICAgICAgIGJnX2JvcmRlcl93aWR0aDogMSxcblxuICAgICAgICAvLyB0cmFjayBiYWNrZ3JvdW5kOlxuICAgICAgICB0cmFja19iZ193aWR0aDogMTAsXG5cbiAgICAgICAgLy8gdHJhY2s6XG4gICAgICAgIHRyYWNrX3dpZHRoOiAxMCxcblxuICAgICAgICAvLyBjdXJzb3JcbiAgICAgICAgY3Vyc29yX3dpZHRoOiAxOCwgICAgICAgICBcbiAgICAgICAgY3Vyc29yX2xlbmd0aDogMTAsXG5cbiAgICAgICAgLy8gYXBwZWFyYW5jZTpcbiAgICAgICAgYmc6IGZhbHNlLFxuICAgICAgICB0cmFja19iZzogdHJ1ZSxcbiAgICAgICAgdHJhY2s6IHRydWUsXG4gICAgICAgIGN1cnNvcjogZmFsc2UsXG4gICAgICAgIC8vIENTUyBjbGFzcyBuYW1lc1xuICAgICAgICBsaW5lY2FwOiAnYnV0dCcsICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWxpbmVjYXBcbiAgICAgICAgdmFsdWVfdGV4dDogdHJ1ZSxcbiAgICAgICAgLy8gdmFsdWVfcG9zaXRpb246IEhBTEZfSEVJR0hUICsgOCwgICAgLy8gZW1waXJpY2FsIHZhbHVlOiBIQUxGX0hFSUdIVCArIGNvbmZpZy5mb250X3NpemUgLyAzXG4gICAgICAgIC8vIHZhbHVlX2Zvcm1hdHRpbmc6IG51bGwsICAgICAgICAgIC8vIFRPRE87IGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGZvcm1hdDogdiA9PiB2LCAgICAgICAgICAgICAgICAgICAgIC8vIGZvcm1hdHRpbmcgb2YgdGhlIGRpc3BsYXllZCB2YWx1ZVxuICAgIFxuICAgICAgICBmb250X2ZhbWlseTogJ3NhbnMtc2VyaWYnLFxuICAgICAgICBmb250X3NpemU6IDI1LFxuICAgICAgICBmb250X3dlaWdodDogJ2JvbGQnLFxuICAgICAgICBcbiAgICAgICAgbWFya2VyczogMCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIG1hcmtlcnM7IDAgb3IgZmFsc2UgdG8gZGlzYWJsZVxuICAgICAgICBtYXJrZXJzX2xlbmd0aDogOCxcbiAgICAgICAgbWFya2Vyc193aWR0aDogMTIsXG5cbiAgICAgICAgY2xhc3NfYmc6ICdzbGlkZXItYmcnLFxuICAgICAgICBjbGFzc190cmFja19iZyA6ICdzbGlkZXItdHJhY2stYmcnLFxuICAgICAgICBjbGFzc190cmFjayA6ICdzbGlkZXItdHJhY2snLFxuICAgICAgICBjbGFzc192YWx1ZSA6ICdzbGlkZXItdmFsdWUnLFxuICAgICAgICBjbGFzc19jdXJzb3IgOiAnc2xpZGVyLWN1cnNvcicsXG4gICAgICAgIGNsYXNzX21hcmtlcnM6ICdzbGlkZXItbWFya2VycycsXG5cbiAgICAgICAgc25hcF90b19zdGVwczogZmFsc2UsICAgICAgIC8vIFRPRE9cblxuICAgICAgICAvLyBtb3VzZSB3aGVlbCBzdXBwb3J0OlxuICAgICAgICBtb3VzZV93aGVlbF9hY2NlbGVyYXRpb246IDEsXG5cbiAgICAgICAgb25jaGFuZ2U6IG51bGwgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgfTtcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ29uc29saWRhdGUgYWxsIGNvbmZpZ3M6XG5cbiAgICBsZXQgZGF0YV9jb25maWcgPSBKU09OLnBhcnNlKGVsZW0uZGF0YXNldC5jb25maWcgfHwgJ3t9Jyk7XG4gICAgLy8gbGV0IGMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgcGFsZXR0ZXNbZGVmYXVsdHMucGFsZXR0ZV0sIGNvbmYsIGRhdGFfY29uZmlnKTtcbiAgICBsZXQgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIGNvbmYsIGRhdGFfY29uZmlnKTtcbiAgICAvLyB3ZSByZS1hc3NpZ24gY29uZiBhbmQgZGF0YV9jb25maWcgZm9yIHRoZSBjYXNlIHRoZXkgb3ZlcnJpZGUgc29tZSBvZiB0aGUgcGFsZXR0ZSBjb2xvcnMuXG4gICAgLy8gbGV0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oYywgcGFsZXR0ZXNbYy5wYWxldHRlXSwgY29uZiwgZGF0YV9jb25maWcpO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBUZXJtaW5hdGVzIHRoZSBTVkcgZWxlbWVudCBzZXR1cDpcblxuICAgIGxldCB2aWV3Ym94X2hlaWdodCA9IDEwMDtcbi8qXG4gICAgaWYgKGNvbmZpZy5sYWJlbCB8fCAoY29uZmlnLnZhbHVlX3Bvc2l0aW9uID49ICgxMDAgLSAoY29uZmlnLmZvbnRfc2l6ZSAvIDIpKSkpIHtcbiAgICAgICAgLy8gbWFrZSBzb21lIHJvb20gZm9yIHRoZSBsYWJlbCBvciB0aGUgdmFsdWUgdGhhdCB3ZSB3YW50IHRvIGRpc3BsYXkgYmVsb3cgdGhlIHNsaWRlclxuICAgICAgICB2aWV3Ym94X2hlaWdodCA9IDEyMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2aWV3Ym94X2hlaWdodCA9IDEwMDtcbiAgICB9XG4qL1xuXG4gICAgLy8gRm9yIHRoZSB1c2Ugb2YgbnVsbCBhcmd1bWVudCB3aXRoIHNldEF0dHJpYnV0ZU5TLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL05hbWVzcGFjZXNfQ3Jhc2hfQ291cnNlI1NjcmlwdGluZ19pbl9uYW1lc3BhY2VkX1hNTFxuICAgIHN2Z19lbGVtZW50LnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy9cIiwgXCJ4bWxuczp4bGlua1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIik7XG4gICAgc3ZnX2VsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ2aWV3Qm94XCIsIGAwIDAgJHtWSUVXQk9YX1dJRFRIfSAke3ZpZXdib3hfaGVpZ2h0fWApO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBpbnRlcm5hbHNcblxuICAgIGxldCB2YWx1ZSA9IDAuMDsgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgc2xpZGVyJ3MgdmFsdWUgW3ZhbHVlX21pbi4udmFsdWVfbWF4XVxuICAgIGxldCBwb3NpdGlvbiA9IGNvbmZpZy5wb3NpdGlvbl9taW47ICAgICAgIC8vIGN1cnJlbnQga25vYidzIHBvc2l0aW9uIGluIFtkZWddIGFuZCBpbiBrbm9iJ3MgY29vcmRpbmF0ZSAobm90IHBvbGFyKVxuICAgIGxldCBtb3VzZV93aGVlbF9kaXJlY3Rpb24gPSAxOyAgICAgIC8vIGRlcGVuZGFudCBvZiB0aGUgT1NcblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU1ZHIGVsZW1lbnRzLCBmcm9tIGJhY2sgdG8gZnJvbnQ6XG4gICAgbGV0IHN2Z19iZyA9IG51bGw7ICAgICAgICAgICAvLyBiYWNrZ3JvdW5kIGRpc2s6XG4gICAgbGV0IHN2Z190cmFja19iZyA9IG51bGw7ICAgICAgICAgICAgLy8gdHJhY2sgYmFja2dyb3VuZDsgZm9yIG5vbiB6ZXJvLWNlbnRlcmVkIHNsaWRlcnNcbiAgICBsZXQgc3ZnX3RyYWNrID0gbnVsbDtcbiAgICBsZXQgc3ZnX2N1cnNvciA9IG51bGw7XG4gICAgbGV0IHN2Z19kaXZpc2lvbnMgPSBudWxsO1xuICAgIGxldCBzdmdfdmFsdWVfdGV4dCA9IG51bGw7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIG1vdXNlIHN1cHBvcnRcbiAgICBsZXQgdGFyZ2V0UmVjdDtcbiAgICBsZXQgbWluRGVsdGFZO1xuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0cnVlIGlmIHRoZSBjdXJyZW50IHNsaWRlciB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgIGxldCBoYXNfY2hhbmdlZCA9IGZhbHNlOyAgICAvLyB0byBzcGFyZSBzb21lIGdldFZhbHVlKCkgY2FsbHMgd2hlbiB0ZXN0aW5nIGlmIHZhbHVlIGhhcyBjaGFuZ2VkIGZyb20gZGVmYXVsdF92YWx1ZVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDcmVhdGUgdGhlIHNsaWRlcjpcblxuICAgIGluaXQoKTtcbiAgICBkcmF3KCk7XG4gICAgYXR0YWNoRXZlbnRIYW5kbGVycygpO1xuXG5cbiAgICAvKipcbiAgICAgKiBIYXZpbmcgYSBpbml0IGZ1bmN0aW9uIGFsbG93IHRoZSBzbGlkZXIgdG8gYmUgcmUtY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0KCkge1xuXG4gICAgICAgIGlmIChjb25maWcuY2VudGVyX3plcm8pIHtcbiAgICAgICAgICAgIGlmICghY29uZmlnLmNlbnRlcl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5jZW50ZXJfdmFsdWUgPSBnZXRSb3VuZGVkVmFsdWUoKGNvbmZpZy52YWx1ZV9tYXggLSBjb25maWcudmFsdWVfbWluKSAvIDIgKyBjb25maWcudmFsdWVfbWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBpbml0aWFsIHZhbHVlIGFuZCBwb3NpdGlvbjpcbiAgICAgICAgc2V0VmFsdWUoY29uZmlnLmluaXRpYWxfdmFsdWUgPyBjb25maWcuaW5pdGlhbF92YWx1ZSA6IGNvbmZpZy5kZWZhdWx0X3ZhbHVlKTtcblxuICAgICAgICAvLyBtb3VzZV93aGVlbF9kaXJlY3Rpb24gPSBfaXNNYWNPUygpID8gLTEgOiAxOyAvL1RPRE86IHJlYWxseSBuZWNlc3Nhcnk/XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBcInJvdW5kZWRcIiBhY2NvcmRpbmcgdG8gY29uZmlnLnZhbHVlX3Jlc29sdXRpb25cbiAgICAgKiBAcGFyYW0gdiB2YWx1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJvdW5kZWRWYWx1ZSh2KSB7XG4gICAgICAgIHJldHVybiBjb25maWcudmFsdWVfcmVzb2x1dGlvbiA9PT0gbnVsbCA/IHYgOiBNYXRoLnJvdW5kKHYgLyBjb25maWcudmFsdWVfcmVzb2x1dGlvbikgKiBjb25maWcudmFsdWVfcmVzb2x1dGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBbZGVnXSBpbiBzbGlkZXIncyBjb29yZGluYXRlc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldERpc3BsYXlWYWx1ZShwb3NpdGlvbikge1xuICAgICAgICBsZXQgdiA9IGdldFZhbHVlKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5mb3JtYXQodik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzbGlkZXIncyB2YWx1ZSBkZXRlcm1pbmVkIGJ5IHRoZSBzbGlkZXIncyBwb3NpdGlvbiAocG9zaXRpb24pXG4gICAgICogQHBhcmFtIGEgW2RlZ10gaW4gc2xpZGVyJ3MgY29vcmRpbmF0ZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFZhbHVlKGEpIHtcbiAgICAgICAgbGV0IHYgPSAoKChhIHx8IHBvc2l0aW9uKSAtIGNvbmZpZy5wb3NpdGlvbl9taW4pIC8gKGNvbmZpZy5wb3NpdGlvbl9tYXggLSBjb25maWcucG9zaXRpb25fbWluKSkgKiAoY29uZmlnLnZhbHVlX21heCAtIGNvbmZpZy52YWx1ZV9taW4pICsgY29uZmlnLnZhbHVlX21pbjtcbiAgICAgICAgcmV0dXJuIGdldFJvdW5kZWRWYWx1ZSh2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2xpZGVyJ3MgdmFsdWVcbiAgICAgKiBAcGFyYW0gdlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHYgPCBjb25maWcudmFsdWVfbWluKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbmZpZy52YWx1ZV9taW47XG4gICAgICAgIH0gZWxzZSBpZiAodiA+IGNvbmZpZy52YWx1ZV9tYXgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gY29uZmlnLnZhbHVlX21heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQb3NpdGlvbigoKHYgLSBjb25maWcudmFsdWVfbWluKSAvIChjb25maWcudmFsdWVfbWF4IC0gY29uZmlnLnZhbHVlX21pbikpICogKGNvbmZpZy5wb3NpdGlvbl9tYXggLSBjb25maWcucG9zaXRpb25fbWluKSArIGNvbmZpZy5wb3NpdGlvbl9taW4pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2xpZGVyJ3MgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gbmV3X3Bvc2l0aW9uIGluIFtkZWddXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UG9zaXRpb24obmV3X3Bvc2l0aW9uLCBmaXJlX2V2ZW50KSB7XG4gICAgICAgIGxldCBwcmV2ID0gcG9zaXRpb247XG4gICAgICAgIGxldCBub3RpZnkgPSBmaXJlX2V2ZW50ICYmIChuZXdfcG9zaXRpb24gIT09IHBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihNYXRoLm1heChuZXdfcG9zaXRpb24sIGNvbmZpZy5wb3NpdGlvbl9taW4pLCBjb25maWcucG9zaXRpb25fbWF4KTtcbiAgICAgICAgaWYgKG5vdGlmeSkge1xuICAgICAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgaWYgdGhlIGNoYW5nZSBvZiBwb3NpdGlvbiBhZmZlY3QgdGhlIHZhbHVlOlxuICAgICAgICAgICAgaWYgKGdldFZhbHVlKHByZXYpICE9PSBnZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgbm90aWZ5Q2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNyZW1lbnQgKG9yIGRlY3JlbWVudCBpZiB0aGUgaW5jcmVtZW50IGlzIG5lZ2F0aXZlKSB0aGUgc2xpZGVyJ3MgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIGluY3JlbWVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluY1Bvc2l0aW9uKGluY3JlbWVudCkge1xuICAgICAgICBzZXRQb3NpdGlvbihNYXRoLm1pbihNYXRoLm1heChwb3NpdGlvbiArIGluY3JlbWVudCwgY29uZmlnLnBvc2l0aW9uX21pbiksIGNvbmZpZy5wb3NpdGlvbl9tYXgpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gcG9sYXIgY29vcmRpbmF0ZXMgcG9zaXRpb24gZnJvbSBvdXIgXCJzbGlkZXIgY29vcmRpbmF0ZXNcIiBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNsaWRlclRvUG9sYXJQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBsZXQgYSA9IGNvbmZpZy56ZXJvX2F0IC0gcG9zaXRpb247XG4gICAgICAgIGlmIChhIDwgMCkgYSA9IGEgKyAzNjAuMDtcbiAgICAgICAgaWYgKHRyYWNlKSBjb25zb2xlLmxvZyhgc2xpZGVyVG9Qb2xhclBvc2l0aW9uICR7cG9zaXRpb259IC0+ICR7YX1gKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gW2RlZ10gd2l0aCAwIGF0IDMgbydjbG9ja1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcG9sYXJUb3NsaWRlclBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIC8vIFwiLVwiIGZvciBjaGFuZ2luZyBDQ1cgdG8gQ1dcbiAgICAgICAgaWYgKHRyYWNlKSBjb25zb2xlLmxvZyhgcG9sYXJUb3NsaWRlclBvc2l0aW9uICR7cG9zaXRpb259IC0+ICR7KGNvbmZpZy56ZXJvX2F0IC0gcG9zaXRpb24gKyAzNjAuMCkgJSAzNjAuMH1gKTtcbiAgICAgICAgcmV0dXJuIChjb25maWcuemVyb19hdCAtIHBvc2l0aW9uICsgMzYwLjApICUgMzYwLjA7ICAgIC8vIHdlIGFkZCAzNjAgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBkb3duIHRvIC0zNjBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdGFydERyYWcoKSBtdXN0IGhhdmUgYmVlbiBjYWxsZWQgYmVmb3JlIHRvIGluaXQgdGhlIHRhcmdldFJlY3QgdmFyaWFibGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW91c2VVcGRhdGUoZSkge1xuXG4gICAgICAgIC8vIE1vdXNlRXZlbnQuY2xpZW50WCAoc3RhbmRhcmQgcHJvcGVydHk6IFlFUylcbiAgICAgICAgLy8gVGhlIGNsaWVudFggcmVhZC1vbmx5IHByb3BlcnR5IG9mIHRoZSBNb3VzZUV2ZW50IGludGVyZmFjZSBwcm92aWRlc1xuICAgICAgICAvLyB0aGUgaG9yaXpvbnRhbCBjb29yZGluYXRlIHdpdGhpbiB0aGUgYXBwbGljYXRpb24ncyBjbGllbnQgYXJlYSBhdCB3aGljaFxuICAgICAgICAvLyB0aGUgZXZlbnQgb2NjdXJyZWQgKGFzIG9wcG9zZWQgdG8gdGhlIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgcGFnZSkuXG4gICAgICAgIC8vIEZvciBleGFtcGxlLCBjbGlja2luZyBpbiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBjbGllbnQgYXJlYSB3aWxsIGFsd2F5c1xuICAgICAgICAvLyByZXN1bHQgaW4gYSBtb3VzZSBldmVudCB3aXRoIGEgY2xpZW50WCB2YWx1ZSBvZiAwLCByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICAgICAgLy8gdGhlIHBhZ2UgaXMgc2Nyb2xsZWQgaG9yaXpvbnRhbGx5LiBPcmlnaW5hbGx5LCB0aGlzIHByb3BlcnR5IHdhcyBkZWZpbmVkXG4gICAgICAgIC8vIGFzIGEgbG9uZyBpbnRlZ2VyLiBUaGUgQ1NTT00gVmlldyBNb2R1bGUgcmVkZWZpbmVkIGl0IGFzIGEgZG91YmxlIGZsb2F0LlxuXG4gICAgICAgIGxldCBkeFBpeGVscyA9IGUuY2xpZW50WCAtIHRhcmdldFJlY3QubGVmdDtcbiAgICAgICAgbGV0IGR5UGl4ZWxzID0gZS5jbGllbnRZIC0gdGFyZ2V0UmVjdC50b3A7XG5cbiAgICAgICAgLy8gbW91c2UgZGVsdGEgaW4gY2FydGVzaWFuIGNvb3JkaW5hdGUgd2l0aCBwYXRoIGNlbnRlcj0wLDAgYW5kIHNjYWxlZCAoLTEuLjAuLjEpIHJlbGF0aXZlIHRvIHBhdGg6XG4gICAgICAgIC8vIDxzdmc+IGNlbnRlcjogICAgICAgKGR4LCBkeSkgPT0gKCAwLCAgMClcbiAgICAgICAgLy8gPHN2Zz4gdG9wLWxlZnQ6ICAgICAoZHgsIGR5KSA9PSAoLTEsICAxKVxuICAgICAgICAvLyA8c3ZnPiBib3R0b20tcmlnaHQ6IChkeCwgZHkpID09ICggMSwgLTEpIChib3R0b20gcmlnaHQgb2YgdGhlIDEwMHgxMDAgdmlld0JveCwgaWdub3JpbmcgdGhlIGJvdHRvbSAxMDB4MjAgZm9yIHRoZSBsYWJlbClcbiAgICAgICAgbGV0IGR4ID0gKGR4UGl4ZWxzIC0gYXJjQ2VudGVyWFBpeGVscykgLyAodGFyZ2V0UmVjdC53aWR0aCAvIDIpO1xuICAgICAgICBsZXQgZHkgPSAtIChkeVBpeGVscyAtIGFyY0NlbnRlcllQaXhlbHMpIC8gKHRhcmdldFJlY3Qud2lkdGggLyAyKTsgIC8vIHRhcmdldFJlY3Qud2lkdGggY2FyIG9uIGEgMjBweCBkZSBwbHVzIGVuIGhhdXRldXIgcG91ciBsZSBsYWJlbFxuXG4gICAgICAgIGlmIChjb25maWcucm90YXRpb24gPT09IENDVykgZHggPSAtIGR4O1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdG8gcG9sYXIgY29vcmRpbmF0ZXNcbiAgICAgICAgbGV0IHBvc2l0aW9uX3JhZCA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uX3JhZCA8IDApIHBvc2l0aW9uX3JhZCA9IDIuMCpNYXRoLlBJICsgcG9zaXRpb25fcmFkO1xuXG4gICAgICAgIGlmICh0cmFjZSkgY29uc29sZS5sb2coYG1vdXNlVXBkYXRlOiBwb3NpdGlvbiBpbiBzdmcgPSAke2R4UGl4ZWxzfSwgJHtkeVBpeGVsc30gcGl4ZWxzOyAke2R4LnRvRml4ZWQoMyl9LCAke2R5LnRvRml4ZWQoMyl9IHJlbC47IHBvc2l0aW9uICR7cG9zaXRpb25fcmFkLnRvRml4ZWQoMyl9IHJhZGApO1xuXG4gICAgICAgIHNldFBvc2l0aW9uKHBvbGFyVG9zbGlkZXJQb3NpdGlvbihwb3NpdGlvbl9yYWQgKiAxODAuMCAvIE1hdGguUEkpLCB0cnVlKTtcblxuICAgICAgICAvLyBkaXN0YW5jZSBmcm9tIGFyYyBjZW50ZXIgdG8gbW91c2UgcG9zaXRpb246XG4gICAgICAgIC8vIGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4KihIQUxGX1dJRFRIL2NvbmZpZy50cmFja193aWR0aCkqZHgqKEhBTEZfV0lEVEgvY29uZmlnLnRyYWNrX3dpZHRoKSArIGR5KihIQUxGX0hFSUdIVC9jb25maWcudHJhY2tfd2lkdGgpKmR5KihIQUxGX0hFSUdIVC9jb25maWcudHJhY2tfd2lkdGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnKGUpIHtcblxuICAgICAgICBpZiAodHJhY2UpIGNvbnNvbGUubG9nKCdzdGFydERyYWcnKTtcblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gQVBJOiBFdmVudC5jdXJyZW50VGFyZ2V0XG4gICAgICAgIC8vICAgICAgSWRlbnRpZmllcyB0aGUgY3VycmVudCB0YXJnZXQgZm9yIHRoZSBldmVudCwgYXMgdGhlIGV2ZW50IHRyYXZlcnNlcyB0aGUgRE9NLiBJdCBhbHdheXMgUkVGRVJTIFRPIFRIRSBFTEVNRU5UXG4gICAgICAgIC8vICAgICAgVE8gV0hJQ0ggVEhFIEVWRU5UIEhBTkRMRVIgSEFTIEJFRU4gQVRUQUNIRUQsIGFzIG9wcG9zZWQgdG8gZXZlbnQudGFyZ2V0IHdoaWNoIGlkZW50aWZpZXMgdGhlIGVsZW1lbnQgb25cbiAgICAgICAgLy8gICAgICB3aGljaCB0aGUgZXZlbnQgb2NjdXJyZWQuXG4gICAgICAgIC8vICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L2N1cnJlbnRUYXJnZXRcblxuICAgICAgICAvLyBjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0O1xuXG4gICAgICAgIC8vIEFQSTogRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSAoc3RhbmRhcmQ6IFlFUylcbiAgICAgICAgLy8gICAgICBUaGUgRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBtZXRob2QgcmV0dXJucyB0aGUgc2l6ZSBvZiBhbiBlbGVtZW50XG4gICAgICAgIC8vICAgICAgYW5kIGl0cyBQT1NJVElPTiBSRUxBVElWRSBUTyBUSEUgVklFV1BPUlQuXG4gICAgICAgIC8vICAgICAgVGhlIGFtb3VudCBvZiBzY3JvbGxpbmcgdGhhdCBoYXMgYmVlbiBkb25lIG9mIHRoZSB2aWV3cG9ydCBhcmVhIChvciBhbnkgb3RoZXJcbiAgICAgICAgLy8gICAgICBzY3JvbGxhYmxlIGVsZW1lbnQpIGlzIHRha2VuIGludG8gYWNjb3VudCB3aGVuIGNvbXB1dGluZyB0aGUgYm91bmRpbmcgcmVjdHBvc2l0aW9uLlxuICAgICAgICAvLyAgICAgIFRoaXMgbWVhbnMgdGhhdCB0aGUgcmVjdHBvc2l0aW9uJ3MgYm91bmRhcnkgZWRnZXMgKHRvcCwgbGVmdCwgYm90dG9tLCBhbmQgcmlnaHQpXG4gICAgICAgIC8vICAgICAgY2hhbmdlIHRoZWlyIHZhbHVlcyBldmVyeSB0aW1lIHRoZSBzY3JvbGxpbmcgcG9zaXRpb24gY2hhbmdlcyAoYmVjYXVzZSB0aGVpclxuICAgICAgICAvLyAgICAgIHZhbHVlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGFuZCBub3QgYWJzb2x1dGUpLlxuICAgICAgICAvLyAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L2dldEJvdW5kaW5nQ2xpZW50UmVjdFxuXG4gICAgICAgIC8vIHRhcmdldFJlY3QgPSBjdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBjdXJyZW50VGFyZ2V0IG11c3QgYmUgdGhlIDxzdmcuLi4+IG9iamVjdFxuICAgICAgICB0YXJnZXRSZWN0ID0gc3ZnX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gTm90ZTogd2UgbXVzdCB0YWtlIHRoZSBib3VuZGluZ0NsaWVudFJlY3Qgb2YgdGhlIDxzdmc+IGFuZCBub3QgdGhlIDxwYXRoPiBiZWNhdXNlIHRoZSA8cGF0aD4gYm91bmRpbmcgcmVjdFxuICAgICAgICAvLyAgICAgICBpcyBub3QgY29uc3RhbnQgYmVjYXVzZSBpdCBlbmNsb3NlcyB0aGUgY3VycmVudCBhcmMuXG5cblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVEcmFnLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBlbmREcmFnLCBmYWxzZSk7XG5cbiAgICAgICAgbW91c2VVcGRhdGUoZSk7XG4gICAgICAgIHJlZHJhdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYW5kbGVEcmFnKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBtb3VzZVVwZGF0ZShlKTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlbmREcmFnKCkge1xuICAgICAgICBpZiAodHJhY2UpIGNvbnNvbGUubG9nKCdlbmREcmFnJyk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZURyYWcsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGVuZERyYWcsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gbW91c2VXaGVlbEhhbmRsZXIoZSkge1xuXG4gICAgICAgIC8vIFdoZWVsRXZlbnRcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgc3RhbmRhcmQgd2hlZWwgZXZlbnQgaW50ZXJmYWNlIHRvIHVzZS4gT2xkIHZlcnNpb25zIG9mIGJyb3dzZXJzIGltcGxlbWVudGVkIHRoZSB0d28gbm9uLXN0YW5kYXJkXG4gICAgICAgIC8vIGFuZCBub24tY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIE1vdXNlV2hlZWxFdmVudCBhbmQgTW91c2VTY3JvbGxFdmVudCBpbnRlcmZhY2VzLiBVc2UgdGhpcyBpbnRlcmZhY2UgYW5kIGF2b2lkXG4gICAgICAgIC8vIHRoZSBsYXR0ZXIgdHdvLlxuICAgICAgICAvLyBUaGUgV2hlZWxFdmVudCBpbnRlcmZhY2UgcmVwcmVzZW50cyBldmVudHMgdGhhdCBvY2N1ciBkdWUgdG8gdGhlIHVzZXIgbW92aW5nIGEgbW91c2Ugd2hlZWwgb3Igc2ltaWxhciBpbnB1dCBkZXZpY2UuXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTUyNzYwMS9ub3JtYWxpemluZy1tb3VzZXdoZWVsLXNwZWVkLWFjcm9zcy1icm93c2Vyc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZml4ZWQtZGF0YS10YWJsZS9ibG9iL21hc3Rlci9zcmMvdmVuZG9yX3Vwc3RyZWFtL2RvbS9ub3JtYWxpemVXaGVlbC5qc1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgZHkgPSBlLmRlbHRhWTtcblxuICAgICAgICBpZiAoZHkgIT09IDApIHtcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBZIGRlbHRhXG4gICAgICAgICAgICBpZiAobWluRGVsdGFZID4gTWF0aC5hYnMoZHkpIHx8ICFtaW5EZWx0YVkpIHtcbiAgICAgICAgICAgICAgICBtaW5EZWx0YVkgPSBNYXRoLmFicyhkeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbmNQb3NpdGlvbihkeSAvIG1pbkRlbHRhWSAqIG1vdXNlX3doZWVsX2RpcmVjdGlvbiAqIGNvbmZpZy5tb3VzZV93aGVlbF9hY2NlbGVyYXRpb24pO1xuXG4gICAgICAgIC8vIFRPRE86IG1vdXNlIHNwZWVkIGRldGVjdGlvbiAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjI1OTMyODYvZGV0ZWN0LW1lYXN1cmUtc2Nyb2xsLXNwZWVkKVxuXG4gICAgICAgIHJlZHJhdygpO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0dGFjaEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIHN2Z19lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc3RhcnREcmFnKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3ZnX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIG1vdXNlV2hlZWxIYW5kbGVyKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vdGlmeUNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRyYWNlKSBjb25zb2xlLmxvZygnc2xpZGVyIHZhbHVlIGhhcyBjaGFuZ2VkJyk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKCk7ICAgICAvLyBUT0RPOiBjYWNoZSB0aGUgdmFsdWVcbiAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjaGFuZ2UnLCB7J2RldGFpbCc6IHZhbHVlfSk7XG4gICAgICAgIC8vc3ZnX2VsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIGlmIChjb25maWcub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIGNvbmZpZy5vbmNoYW5nZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbmZpZ3VyZSB0aGUgbW91c2V3aGVlbCBkaXJlY3Rpb24uXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfaXNNYWNPUygpIHtcbiAgICAgICAgcmV0dXJuIFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnXS5pbmRleE9mKHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdmlld0JveCBYLFkgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gaW4gW2RlZ3JlZV0gKHBvbGFyLCAwIGF0IDMgbydjbG9jaylcbiAgICAgKiBAcGFyYW0gcmFkaXVzOyBkZWZhdWx0cyB0byBjb25maWcucmFkaXVzXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Vmlld2JveENvb3JkKHBvc2l0aW9uLCByYWRpdXMpIHtcbi8qXG4gICAgICAgIGxldCBhID0gcG9zaXRpb24gKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgIGxldCByID0gcmFkaXVzIHx8IGNvbmZpZy50cmFja193aWR0aDtcbiAgICAgICAgbGV0IHggPSBNYXRoLmNvcyhhKSAqIHI7XG4gICAgICAgIGxldCB5ID0gTWF0aC5zaW4oYSkgKiByO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY29uZmlnLnJvdGF0aW9uID09PSBDVyA/IChIQUxGX1dJRFRIICsgeCkgOiAoSEFMRl9XSURUSCAtIHgpLFxuICAgICAgICAgICAgeTogSEFMRl9IRUlHSFQgLSB5XG4gICAgICAgIH1cbiovXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbV9wb3NpdGlvbiBpbiBbZGVncmVlXSBpbiBzbGlkZXIncyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB0b19wb3NpdGlvbiBpbiBbZGVncmVlXSBpbiBzbGlkZXIncyBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSByYWRpdXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBcmMoZnJvbV9wb3NpdGlvbiwgdG9fcG9zaXRpb24sIHJhZGl1cykge1xuXG4gICAgICAgIGlmICh0cmFjZSkgY29uc29sZS5ncm91cChgZ2V0QXJjKCR7ZnJvbV9wb3NpdGlvbn0sICR7dG9fcG9zaXRpb259LCAke3JhZGl1c30pYCk7XG5cbiAgICAgICAgLy8gU1ZHIGQ6IFwiQSByeCxyeSB4QXhpc1JvdGF0ZSBMYXJnZUFyY0ZsYWcsU3dlZXBGbGFnIHgseVwiLlxuICAgICAgICAvLyBTd2VlcEZsYWcgaXMgZWl0aGVyIDAgb3IgMSwgYW5kIGRldGVybWluZXMgaWYgdGhlIGFyYyBzaG91bGQgYmUgc3dlcHQgaW4gYSBjbG9ja3dpc2UgKDEpLCBvciBhbnRpLWNsb2Nrd2lzZSAoMCkgZGlyZWN0aW9uXG4gICAgICAgIC8vIHJlZjogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9kXG5cbiAgICAgICAgbGV0IGEwID0gc2xpZGVyVG9Qb2xhclBvc2l0aW9uKGZyb21fcG9zaXRpb24pO1xuICAgICAgICBsZXQgYTEgPSBzbGlkZXJUb1BvbGFyUG9zaXRpb24odG9fcG9zaXRpb24pO1xuXG4gICAgICAgIC8vIGxpdHRsZSB0cmljayB0byBmb3JjZSBhIGZ1bGwgYXJjICgzNjBkZWcpIHdoZW4gZnJvbT0wIGFuZCB0bz0zNjBcbiAgICAgICAgaWYgKGZyb21fcG9zaXRpb24gIT09IHRvX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyB3aXRoIHRoaXMgd2UgbWFrZSBzdXJlIHRoYXQgeDEgd2lsbCBiZSBkaWZmZXJlbnQgdGhhbiB4MCB3aXRoaW4gdGhlIHBhdGggZGVmaW5pdGlvblxuICAgICAgICAgICAgYTAgLT0gMC4wMDAxO1xuICAgICAgICAgICAgYTEgKz0gMC4wMDAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHt4OiB4MCwgeTogeTB9ID0gZ2V0Vmlld2JveENvb3JkKGEwLCByYWRpdXMpO1xuICAgICAgICBsZXQge3g6IHgxLCB5OiB5MX0gPSBnZXRWaWV3Ym94Q29vcmQoYTEsIHJhZGl1cyk7XG5cbiAgICAgICAgbGV0IGRlbHRhX3Bvc2l0aW9uID0gKGEwIC0gYTEgKyAzNjAuMCkgJSAzNjAuMDtcblxuICAgICAgICBsZXQgbGFyZ2VfYXJjID0gZGVsdGFfcG9zaXRpb24gPCAxODAuMCA/IDAgOiAxO1xuICAgICAgICBsZXQgYXJjX2RpcmVjdGlvbiA9IGNvbmZpZy5yb3RhdGlvbiA9PT0gQ1cgPyAxIDogMDtcblxuICAgICAgICBsZXQgcCA9IGBNICR7eDB9LCR7eTB9IEEgJHtyYWRpdXN9LCR7cmFkaXVzfSAwICR7bGFyZ2VfYXJjfSwke2FyY19kaXJlY3Rpb259ICR7eDF9LCR7eTF9YDtcblxuICAgICAgICBpZiAodHJhY2UpIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICAgICAgaWYgKHRyYWNlKSBjb25zb2xlLmxvZyhcImFyYzogXCIgKyBwKTtcblxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFRyYWNrUGF0aCgpIHtcblxuICAgICAgICBsZXQgcCA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5jZW50ZXJfemVybykge1xuXG4gICAgICAgICAgICBpZiAoZ2V0VmFsdWUoKSA9PT0gY29uZmlnLmNlbnRlcl92YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFjZSkgY29uc29sZS5sb2coJ2dldFRyYWNrUGF0aDogY2VudGVyIHBvc2l0aW9uLCB0cmFjayBub3QgZHJhd24nKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFjayBpcyBub3QgZHJhd24gd2hlbiB0aGUgdmFsdWUgaXMgYXQgY2VudGVyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdlIGFzc3VtZSB0aGUgc3BsaXQgaXMgYXQgMTgwIFtkZWddIChzbGlkZXIncyBwb3NpdGlvbilcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDE4MCkge1xuICAgICAgICAgICAgICAgIHAgPSBnZXRBcmMoTWF0aC5taW4ocG9zaXRpb24sIGxlZnRfdHJhY2tfZW5kX3Bvc2l0aW9uKSwgbGVmdF90cmFja19lbmRfcG9zaXRpb24sIGNvbmZpZy50cmFja193aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gMTgwKSB7XG4gICAgICAgICAgICAgICAgcCA9IGdldEFyYyhyaWdodF90cmFja19zdGFydF9wb3NpdGlvbiwgTWF0aC5tYXgocG9zaXRpb24sIHJpZ2h0X3RyYWNrX3N0YXJ0X3Bvc2l0aW9uKSwgY29uZmlnLnRyYWNrX3dpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IGdldEFyYyhjb25maWcucG9zaXRpb25fbWluLCBwb3NpdGlvbiwgY29uZmlnLnRyYWNrX3dpZHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhd19iYWNrZ3JvdW5kKCkge1xuXG4gICAgICAgIGlmICghY29uZmlnLmJnKSByZXR1cm47XG5cbiAgICAgICAgLy8gRm9yIHRoZSB1c2Ugb2YgbnVsbCBhcmd1bWVudCB3aXRoIHNldEF0dHJpYnV0ZU5TLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL05hbWVzcGFjZXNfQ3Jhc2hfQ291cnNlI1NjcmlwdGluZ19pbl9uYW1lc3BhY2VkX1hNTFxuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJhY2sgZGlzazpcbiAgICAgICAgLy9cbiAgICAgICAgc3ZnX2JnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKE5TLCBcImNpcmNsZVwiKTtcbiAgICAgICAgc3ZnX2JnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgYCR7SEFMRl9XSURUSH1gKTtcbiAgICAgICAgc3ZnX2JnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgYCR7SEFMRl9IRUlHSFR9YCk7XG4gICAgICAgIHN2Z19iZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgYCR7Y29uZmlnLmJnX3dpZHRofWApO1xuICAgICAgICBzdmdfYmcuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBgJHtjb25maWcuYmdfY29sb3J9YCk7XG4gICAgICAgIHN2Z19iZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgYCR7Y29uZmlnLmJnX2JvcmRlcl9jb2xvcn1gKTtcbiAgICAgICAgc3ZnX2JnLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBgJHtjb25maWcuYmdfYm9yZGVyX3dpZHRofWApO1xuICAgICAgICBzdmdfYmcuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY29uZmlnLmNsYXNzX2JnKTtcbiAgICAgICAgc3ZnX2VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnX2JnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXdfbWFya2VycygpIHtcblxuICAgICAgICBpZiAoIWNvbmZpZy5tYXJrZXJzKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHAgPSAnJztcbiAgICAgICAgbGV0IHN0ZXAgPSAoY29uZmlnLnBvc2l0aW9uX21heCAtIGNvbmZpZy5wb3NpdGlvbl9taW4pIC8gY29uZmlnLm1hcmtlcnM7XG4gICAgICAgIGZvciAobGV0IGEgPSBjb25maWcucG9zaXRpb25fbWluOyBhIDw9IGNvbmZpZy5wb3NpdGlvbl9tYXg7IGEgKz0gc3RlcCkge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBnZXRWaWV3Ym94Q29vcmQoc2xpZGVyVG9Qb2xhclBvc2l0aW9uKGEpLCBjb25maWcubWFya2Vyc193aWR0aCk7ICAgIC8vIGdldFZpZXdib3hDb29yZChwb3NpdGlvbiwgcmFkaXVzKVxuICAgICAgICAgICAgbGV0IHRvID0gZ2V0Vmlld2JveENvb3JkKHNsaWRlclRvUG9sYXJQb3NpdGlvbihhKSwgY29uZmlnLm1hcmtlcnNfd2lkdGggKyBjb25maWcubWFya2Vyc19sZW5ndGgpO1xuICAgICAgICAgICAgcCArPSBgTSAke2Zyb20ueH0sJHtmcm9tLnl9IEwgJHt0by54fSwke3RvLnl9IGA7XG4gICAgICAgIH1cblxuICAgICAgICBzdmdfZGl2aXNpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKE5TLCBcInBhdGhcIik7XG4gICAgICAgIHN2Z19kaXZpc2lvbnMuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIHApO1xuICAgICAgICBzdmdfZGl2aXNpb25zLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBgJHtjb25maWcubWFya2Vyc19jb2xvcn1gKTtcbiAgICAgICAgc3ZnX2RpdmlzaW9ucy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7Y29uZmlnLm1hcmtlcnNfd2lkdGh9YCk7XG4gICAgICAgIHN2Z19kaXZpc2lvbnMuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgY29uZmlnLmxpbmVjYXApO1xuICAgICAgICBzdmdfZGl2aXNpb25zLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNvbmZpZy5jbGFzc19tYXJrZXJzKTtcbiAgICAgICAgc3ZnX2VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnX2RpdmlzaW9ucyk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgICAgICAgIGZ1bmN0aW9uIGRyYXdfdW5pdHMoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvcyA9IGdldFZpZXdib3hDb29yZChwb3NpdGlvbl9taW5fcG9sYXIsIGNvbmZpZy5kaXZpc2lvbnNfd2lkdGgpOyAgICAvLyBnZXRWaWV3Ym94Q29vcmQocG9zaXRpb24sIHJhZGl1cylcbiAgICAgICAgICAgICAgICBzdmdfdmFsdWVfdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhOUywgXCJ0ZXh0XCIpO1xuICAgICAgICAgICAgICAgIHN2Z192YWx1ZV90ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBgJHtwb3MueH1gKTtcbiAgICAgICAgICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYCR7cG9zLnl9YCk7XG4gICAgICAgICAgICAgICAgLy8gc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgICAgICAgc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwiY3Vyc29yXCIsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LWZhbWlseVwiLCBjb25maWcuZm9udF9mYW1pbHkpO1xuICAgICAgICAgICAgICAgIHN2Z192YWx1ZV90ZXh0LnNldEF0dHJpYnV0ZShcImZvbnQtc2l6ZVwiLCBgMTBgKTtcbiAgICAgICAgICAgICAgICAvLyBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LXdlaWdodFwiLCBgJHtjb25maWcuZm9udF93ZWlnaHR9YCk7XG4gICAgICAgICAgICAgICAgc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBjb25maWcuZm9udF9jb2xvcik7XG4gICAgICAgICAgICAgICAgLy8gc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY29uZmlnLmNsYXNzX3ZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBzdmdfdmFsdWVfdGV4dC50ZXh0Q29udGVudCA9IGdldERpc3BsYXlWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHN2Z192YWx1ZV90ZXh0LnRleHRDb250ZW50ID0gY29uZmlnLnZhbHVlX21pbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHN2Z19lbGVtZW50LmFwcGVuZENoaWxkKHN2Z192YWx1ZV90ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3X3RyYWNrX2JhY2tncm91bmQoKSB7XG5cbiAgICAgICAgLy8gRm9yIHRoZSB1c2Ugb2YgbnVsbCBhcmd1bWVudCB3aXRoIHNldEF0dHJpYnV0ZU5TLCBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL05hbWVzcGFjZXNfQ3Jhc2hfQ291cnNlI1NjcmlwdGluZ19pbl9uYW1lc3BhY2VkX1hNTFxuXG4gICAgICAgIGlmICghY29uZmlnLnRyYWNrX2JnKSByZXR1cm47XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gdHJhY2sgYmFja2dyb3VuZDpcbiAgICAgICAgLy9cblxuLypcbiAgICAgICAgICAgIHN2Z190cmFja19iZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhOUywgXCJwYXRoXCIpO1xuICAgICAgICAgICAgc3ZnX3RyYWNrX2JnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBnZXRBcmMoY29uZmlnLnBvc2l0aW9uX21pbiwgY29uZmlnLnBvc2l0aW9uX21heCwgY29uZmlnLnRyYWNrX2JnX3dpZHRoKSk7XG4gICAgICAgICAgICBzdmdfdHJhY2tfYmcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIGAke2NvbmZpZy50cmFja19iZ19jb2xvcn1gKTtcbiAgICAgICAgICAgIHN2Z190cmFja19iZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7Y29uZmlnLnRyYWNrX2JnX3dpZHRofWApO1xuICAgICAgICAgICAgc3ZnX3RyYWNrX2JnLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgICAgICAgIHN2Z190cmFja19iZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBjb25maWcubGluZWNhcCk7XG4gICAgICAgICAgICBzdmdfdHJhY2tfYmcuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY29uZmlnLmNsYXNzX3RyYWNrX2JnKTtcbiAgICAgICAgICAgIHN2Z19lbGVtZW50LmFwcGVuZENoaWxkKHN2Z190cmFja19iZyk7XG4qL1xuXG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXdfdHJhY2soKSB7XG4gICAgICAgIGlmICghY29uZmlnLnRyYWNrKSByZXR1cm47XG4gICAgICAgIGxldCBwID0gZ2V0VHJhY2tQYXRoKCk7XG4gICAgICAgIGlmIChwKSB7XG4vKlxuICAgICAgICAgICAgc3ZnX3RyYWNrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKE5TLCBcInBhdGhcIik7XG4gICAgICAgICAgICBzdmdfdHJhY2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIHApO1xuICAgICAgICAgICAgc3ZnX3RyYWNrLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBgJHtjb25maWcudHJhY2tfY29sb3JfaW5pdH1gKTtcbiAgICAgICAgICAgIHN2Z190cmFjay5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7Y29uZmlnLnRyYWNrX3dpZHRofWApO1xuICAgICAgICAgICAgc3ZnX3RyYWNrLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgICAgICAgIHN2Z190cmFjay5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBjb25maWcubGluZWNhcCk7XG4gICAgICAgICAgICBzdmdfdHJhY2suc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY29uZmlnLmNsYXNzX3RyYWNrKTtcbiAgICAgICAgICAgIHN2Z19lbGVtZW50LmFwcGVuZENoaWxkKHN2Z190cmFjayk7XG4qL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFRyYWNrQ3Vyc29yKCkge1xuICAgICAgICAvLyBsZXQgYSA9IHNsaWRlclRvUG9sYXJQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGxldCBmcm9tID0gZ2V0Vmlld2JveENvb3JkKGEsIGNvbmZpZy5jdXJzb3Jfd2lkdGgpO1xuICAgICAgICBsZXQgdG8gPSBnZXRWaWV3Ym94Q29vcmQoYSwgY29uZmlnLmN1cnNvcl93aWR0aCArIGNvbmZpZy5jdXJzb3JfbGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGBNICR7ZnJvbS54fSwke2Zyb20ueX0gTCAke3RvLnh9LCR7dG8ueX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhd19jdXJzb3IoKSB7XG5cbiAgICAgICAgaWYgKCFjb25maWcuY3Vyc29yKSByZXR1cm47XG5cbiAgICAgICAgbGV0IHAgPSBnZXRUcmFja0N1cnNvcigpO1xuICAgICAgICBpZiAocCkge1xuLypcbiAgICAgICAgICAgIHN2Z19jdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoTlMsIFwicGF0aFwiKTtcbiAgICAgICAgICAgIHN2Z19jdXJzb3Iuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIHApO1xuICAgICAgICAgICAgc3ZnX2N1cnNvci5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgYCR7Y29uZmlnLmN1cnNvcl9jb2xvcl9pbml0fWApO1xuICAgICAgICAgICAgc3ZnX2N1cnNvci5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYCR7Y29uZmlnLmN1cnNvcl93aWR0aH1gKTtcbiAgICAgICAgICAgIHN2Z19jdXJzb3Iuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgICAgICAgc3ZnX2N1cnNvci5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtbGluZWNhcFwiLCBjb25maWcubGluZWNhcCk7XG4gICAgICAgICAgICBzdmdfY3Vyc29yLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNvbmZpZy5jbGFzc19jdXJzb3IpO1xuICAgICAgICAgICAgc3ZnX2VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnX2N1cnNvcik7XG4qL1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3X3ZhbHVlKCkge1xuXG4gICAgICAgIGlmICghY29uZmlnLnZhbHVlX3RleHQpIHJldHVybjtcblxuLypcbiAgICAgICAgc3ZnX3ZhbHVlX3RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoTlMsIFwidGV4dFwiKTtcbiAgICAgICAgc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGAke0hBTEZfV0lEVEh9YCk7XG4gICAgICAgIHN2Z192YWx1ZV90ZXh0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBgJHtjb25maWcudmFsdWVfcG9zaXRpb259YCk7XG4gICAgICAgIHN2Z192YWx1ZV90ZXh0LnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJjdXJzb3JcIiwgXCJkZWZhdWx0XCIpO1xuICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LWZhbWlseVwiLCBjb25maWcuZm9udF9mYW1pbHkpO1xuICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJmb250LXNpemVcIiwgYCR7Y29uZmlnLmZvbnRfc2l6ZX1gKTtcbiAgICAgICAgc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwiZm9udC13ZWlnaHRcIiwgYCR7Y29uZmlnLmZvbnRfd2VpZ2h0fWApO1xuICAgICAgICBzdmdfdmFsdWVfdGV4dC5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIGNvbmZpZy5mb250X2NvbG9yKTtcbiAgICAgICAgc3ZnX3ZhbHVlX3RleHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgY29uZmlnLmNsYXNzX3ZhbHVlKTtcbiAgICAgICAgc3ZnX3ZhbHVlX3RleHQudGV4dENvbnRlbnQgPSBnZXREaXNwbGF5VmFsdWUoKTtcbiAgICAgICAgc3ZnX2VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnX3ZhbHVlX3RleHQpO1xuKi9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICAgIGRyYXdfYmFja2dyb3VuZCgpO1xuICAgICAgICBkcmF3X3RyYWNrX2JhY2tncm91bmQoKTtcbiAgICAgICAgZHJhd19tYXJrZXJzKCk7XG4gICAgICAgIC8vIGRyYXdfdW5pdHMoKTtcbiAgICAgICAgZHJhd190cmFjaygpO1xuICAgICAgICBkcmF3X2N1cnNvcigpO1xuICAgICAgICBkcmF3X3ZhbHVlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWRyYXcoKSB7XG5cbiAgICAgICAgbGV0IHAgPSBnZXRUcmFja1BhdGgoKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGlmIChzdmdfdHJhY2spIHtcbiAgICAgICAgICAgICAgICBzdmdfdHJhY2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIHApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmF3X3RyYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ZnX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgc3ZnX3RyYWNrLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBcIlwiKTsgICAgLy8gd2UgaGlkZSB0aGUgdHJhY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzX2NoYW5nZWQpIHtcbiAgICAgICAgICAgIGhhc19jaGFuZ2VkID0gZ2V0VmFsdWUoKSAhPT0gY29uZmlnLmRlZmF1bHRfdmFsdWU7XG4gICAgICAgICAgICBpZiAoaGFzX2NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ZnX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Z190cmFjay5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgYCR7Y29uZmlnLnRyYWNrX2NvbG9yfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBnZXRUcmFja0N1cnNvcigpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaWYgKHN2Z19jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBzdmdfY3Vyc29yLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBwKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzX2NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnX2N1cnNvci5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgYCR7Y29uZmlnLmN1cnNvcl9jb2xvcn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3ZnX3ZhbHVlX3RleHQpIHtcbiAgICAgICAgICAgIHN2Z192YWx1ZV90ZXh0LnRleHRDb250ZW50ID0gZ2V0RGlzcGxheVZhbHVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldHVybiB7XG4gICAgICAgIHNldCB2YWx1ZSh2KSB7XG4gICAgICAgICAgICBzZXRWYWx1ZSh2KTtcbiAgICAgICAgICAgIHJlZHJhdygpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY29uZmlnKG5ld19jb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBjb25mLCBuZXdfY29uZmlnKTtcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgICAgIGRyYXcoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5hYmxlRGVidWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJhY2UgPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlRGVidWc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdHJhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3N2Zy1zbGlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==